import subprocess
import os
import tempfile
import numpy as np

from uq_kernel.model import UQModel

class SpringMassUQModel(UQModel):
    """
    Defines Spring Mass model with 1 free param (stiffness of spring, k). The
    quantity of interest that is returned by the evaluate() function is the
    maximum displacement over the specified time interval.

    The implementation for this model relies on a system call to a separate
    Python model. This represents the general case where a user's model is an
    arbitrary executable that must be run with a system call and an appropriate
    input file on disk. Outputs are obtained from an output file generated by
    the executable.
    """
    def __init__(self, mass=1.5, gravity=9.8, time_step=None, cost=None):

        self.mass = mass
        self.gravity = gravity
        self.time_step = time_step
        self._cost = cost
    
    def evaluate(self, inputs):
        """
        Returns the max displacement over the course of the simulation.
        MLMCPy convention is that evaluate takes in an array and returns
        an array (even for 1D examples like this one).
        """
        tmpdir = tempfile.mkdtemp()
        self.tmp_input_file = os.path.join(tmpdir, "input.txt")
        self.tmp_output_file = os.path.join(tmpdir, "output.txt")

        #Three primary steps for running a general simulation executable:
        self.write_input_file(inputs)
        self.execute_model()
        output = self.parse_output_file()

        os.remove(self.tmp_input_file)
        os.remove(self.tmp_output_file)
        os.rmdir(tmpdir)

        return np.array([output])

    @property
    def cost(self):
        return self.cost

    def write_input_file(self, inputs):
        """
        This function writes the model's attributes and the given stiffness
        to the tmp_input_file.
        For this particular example, only a 1D array is needed. But, this
        function can be refactored for multi-dimentional arrays, too.
        """
        input_dict = {"mass": self.mass, "gravity": self.gravity,
                      "time_step": self.time_step, "cost": self._cost,
                       "stiffness": inputs[0]}

        with open(self.tmp_input_file, "w+") as fid:
           for key, val in input_dict.items():
                fid.write(key + "=" + str(val))
                fid.write("\n")

    def execute_model(self):
        """
        This function makes a system call to run the original 
        spring mass model with Python.
        Data is passed to and from the original spring mass model
        via input and output files.
        """
        p = subprocess.Popen(["python", "spring_mass_simulation.py", \
            self.tmp_input_file, self.tmp_output_file], \
            stderr=subprocess.PIPE)
        
        #Wait for execution of the model to complete and check for errors 
        std_error = p.communicate()[1]

    def parse_output_file(self):
        """
        This function reads the data from the output file and returns it.
        """
        return np.genfromtxt(self.tmp_output_file)

